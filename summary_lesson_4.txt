Пропущенные данные в R: 
    Na                      - не доступно
    NaN                     - не число
    is.na()                 - функция проверки на пропущенные данные
    is.nan()                - функция проверки на NaN
    c<-0/0                  - NaN
    airquality[is.na(airquality)]       - пропущенные данные ?
    compale.cases()                     - сравнение двух векторов
        data <- data.frame(col1 = c(1, 2, NA, 4), col2 = c(2, NA, 4, 5), col3 = c(NA, 3, 5, 6))
        complete.cases(data) 
        # Результат: [1] FALSE FALSE FALSE  TRUE
    na.omit() - удаление пропущенных данных
        data <- data.frame(col1 = c(1, 2, NA, 4), col2 = c(2, NA, 4, 5), col3 = c(NA, 3, 5, 6))
        na.omit(data)
        # Результат: col1 col2 col3
        #            1    2    3
        #            4    5    6
    compale.cases(airquality) - функция возращает логический вектор который указывает, какие строки в детасете содержит полные данные
    airquality[complete.cases(airquality),] - удаление строк с пропущенными данными и возвращяет только те строки которые содержат полные данные
    na.omit(airquality) - удаление строк с пропущенными данными, которые содержат хотя бы одно пропущенное значение
    Пример кода: 
        # создание датафрейма с пропущенными значениями
        df <- data.frame(x = c(1, 2, NA, 4), y = c(5, NA, 7, 8))
        # вывод логического вектора, указывающего, какие строки содержат полные данные
        complete.cases(df)
        # [1]  TRUE FALSE FALSE  TRUE
        # фильтрация строк с полными данными
        df[complete.cases(df),]
        #   x y
        # 1 1 5
        # 4 4 8
        # удаление строк с пропущенными значениями
        na.omit(df)
        #   x y
        # 1 1 5
        # 4 4 8
    seq(from, to, by, length.out, along.with) - создает последовательность чисел
        seq(1, 10, 2) # 1 3 5 7 9
        seq(1, 10, length.out = 5) # 1 3 5 7 9
        seq(1, 10, length.out = 5, along.with = 1:10) # 1 3 5 7 9
        from - начальное значение 
        to - конечное значение
        by - шаг
        length.out - количество элементов в последовательности
        along.with - вектор, который определяет длину последовательности
        rep(x, times, length.out) - повторяет элементы вектора
    Пример кода:
        # Создание последовательности от 1 до 10 с шагом 1
        seq(1, 10, 1)
        # [1] 1 2 3 4 5 6 7 8 9 10
        # Создание последовательности от 0 до 1 с шагом 0.1
        seq(0, 1, 0.1)
        # [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
        # Создание последовательности от 1 до 10 длиной 5
        seq(1, 10, length.out = 5)
        # [1]  1.00  3.25  5.50  7.75 10.00
        # Создание последовательности, длина которой соответствует длине другого объекта
        vec <- c(10, 20, 30, 40, 50)
        seq(along.with = vec)
        # [1] 1 2 3 4 5
    seq_along(x) - создает последовательность чисел, длина которой соответствует длине объекта x
    seq_len(n) - создает последовательность чисел, длина которой равна n
        rep(1, 5) - повторяет элемент 1 5 раз
        rep(1:3, 5) - повторяет элементы вектора 1:3 5 раз
        rep(c(1, 2), each=3) - повторяет элементы вектора 1 и 2 3 раза
        rep(c(1, 2), times=3) - повторяет элементы вектора 1 и 2 3 раза
        rep(c(1, 2), length.out=5) - повторяет элементы вектора 1 и 2 5 раз
    rep(x, [times, length.out, each]) - повторяет элементы вектора
        x - вектор, который нужно повторить
        times - количество повторений
        length.out - длина вектора
        each - количество повторений каждого элемента
    paste(x, [sep, collapse]) - объединяет элементы вектора в строку
        x - вектор, который нужно объединить
        sep - разделитель
        collapse - разделитель
    Пример кода: 
        # пример использования paste для объединения векторов
        vector1 <- c("red", "blue", "green")
        vector2 <- c("apple", "banana", "orange")
        paste(vector1, vector2)
        # результат: "red apple" "blue banana" "green orange"
        # пример использования paste0 для объединения строковых значений
        string1 <- "hello"
        string2 <- "world"
        paste0(string1, string2)
        # результат: "helloworld"
        # пример использования paste с разделителем
        vector3 <- c("cat", "dog", "bird")
        paste("I have a", vector3, sep=" ")
        # результат: "I have a cat" "I have a dog" "I have a bird"
    sample(x, [size, replace, prob]) - выбирает случайные элементы из вектора
        x - вектор, из которого нужно выбрать элементы
        size - количество элементов, которые нужно выбрать
        replace - логическое значение, указывающее, нужно ли возвращать элементы обратно в вектор
        prob - вектор вероятностей, которые соответствуют элементам вектора x
    Пример кода: 
        # Генерация случайного значения из вектора 1:5
        sample(1:5, 1) 
        # Генерация 5 случайных значений из вектора 1:5
        sample(1:5, 5)
        # Генерация 5 случайных значений из вектора 1:5 с заменой
        sample(1:5, 5, replace = TRUE)
        # Генерация 10 случайных значений из вектора 1:5 с заменой
        sample(1:5, 10, replace = TRUE)
        # Генерация 10 случайных значений из вектора 1:5 без замены. Обратите внимание, что происходит ошибка, так как в векторе только 5 значений
        sample(1:5, 10)
        # Генерация 10 строк в формате "user_N" (где N - случайное число от 1 до 1000)
        paste0("user_", sample(1:1000, 10))
        # Генерация 10 случайных значений из вектора c("Yes", "No") с заменой
        sample(c("Yes", "No"), 10, replace = TRUE)
        # Генерация 10 случайных значений из вектора 1:10 с заменой, где вероятность выбора последнего значения (10) в 10 раз выше, чем остальных значений
        sample(1:10, 10, replace = TRUE, prob = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 10))
    Date() - возвращает текущую дату
    Sys.Date() - возвращает текущую дату в формате YYYY-MM-DD
    as.Date(x, [format]) - преобразует объект в дату
        x - объект, который нужно преобразовать
        format - формат даты
    Пример кода:
        # создаем строку с датой
        date_string <- "2022-04-26"
        # преобразуем строку в объект класса Date
        date_object <- as.Date(date_string)
        # выводим объект класса Date
        date_object
        # получаем текущую дату
        current_date <- Sys.Date()
        # выводим текущую дату
        current_date
        d <- Sys.Date() # сохраняем текущую дату в переменную d
        print(d) # выводим значение переменной d
        d <- Sys.Date() # сохраняем текущую дату в переменную d
        print(class(d)) # выводим класс переменной d
        print(typeof(d)) # выводим внутренний тип данных переменной d
    d <- "2023-04-17" - в данной строке создается переменная d и присваивается значение в формате "год-месяц-день".
    dd <- as.Date(d) - в этой строке происходит преобразование значения переменной d в формат даты и присваивание результата новой переменной dd.
    class(dd) , typeof(dd) - эта строка выводит информацию о классе и типе переменной dd. В данном случае, классом будет "Date", а типом - "double".
    as.Date("1 July 2020") - в этом примере преобразовывается текстовая строка "1 July 2020" в формат даты. В результате получается значение "2020-07-01".
    ?strftime - данная строка вызывает справку по функции strftime(), которая используется для форматирования даты и времени.
    as.Date("1 July 2020","%d %B %Y") - в этом примере преобразовывается текстовая строка "1 July 2020" в формат даты с помощью функции as.Date(). Параметр "%d %B %Y" указывает на формат даты в строке, где "%d" обозначает день, "%B" - месяц полностью, а "%Y" - год. В результате получается значение "2020-07-01".
    Sys.setlocale("LC_TIME", "pl_PL") - данная строка устанавливает локаль на язык польский, чтобы можно было корректно преобразовать дату на польском языке.
    as.Date("1 stycznia 2020", "%d %B %Y") - в этом примере преобразовывается текстовая строка "1 stycznia 2020" (что означает "1 января 2020" на польском языке) в формат даты с помощью функции as.Date(). Параметр "%d %B %Y" указывает на формат даты в строке на польском языке, где "%d" обозначает день, "%B" - месяц полностью, а "%Y" - год. В результате получается значение "2020-01-01".
    Пример кода: 
        d <- "2023-04-17"  # создание переменной d и присваивание ей значения даты
        dd <- as.Date(d)   # преобразование значения d в формат даты и сохранение в переменную dd
        class(dd) , typeof(dd)  # вывод информации о классе и типе переменной dd
    # Создание переменной "today" с текущей датой
    today <- Sys.Date()
    # Преобразование значения "today" в строку в формате "ГГГГ-ММ-ДД"
    format(today)
    # Преобразование значения "today" в строку в формате "День Месяц Год"
    format(today, "%d %B %Y")
    # Вывод значения переменной "today"
    today
    # Вычисление даты следующего дня после значения переменной "today"
    today + 1
    # Создание переменной "data_ur" и присваивание ей значения даты "12 января 1982 года"
    data_ur <- as.Date("1982-01-12")
    # Вычисление разницы между датами "today" и "data_ur" в днях
    today - data_ur
    # Преобразование результата вычисления разницы дат в числовой формат
    as.numeric(today - data_ur)
        # Получаем текущую дату
        today <- Sys.Date()
        # Создаем последовательность дат от сегодняшней даты минус 40 дней до сегодняшней даты включительно с шагом 4 дня
        seq(today-40, today, by=4)
    # Создаем две data.frames
    df1 <- data.frame(id = c(1, 2, 3), name = c("Alice", "Bob", "Charlie"))
    df2 <- data.frame(id = c(2, 3, 4), age = c(25, 30, 35))
    # Объединяем две data.frames на основе столбца "id"
    merged_df <- merge(df1, df2, by = "id")
        marge(df1, df2, by = "id", all = TRUE) # объединяем две data.frames на основе столбца "id" и выводим все строки из обеих data.frames
        df - data.frame, который содержит данные
        by - столбец, по которому происходит объединение
        all - логический параметр, который указывает, нужно ли выводить все строки из обеих data.frames.
    Загрузка данных из CSV файла в объект "df" с помощью функции read.csv().
    Создание новой колонки "userNames" путем объединения имени из столбца "Name" с случайным числом от 1 до 1000 с помощью функции paste0() и tolower().
    Создание новой колонки "emails" путем объединения "userNames" и постфикса "@ujd.edu.pl" с помощью функции paste0().
    Создание нового объекта "df2", который содержит только три столбца: "Name", "userNames" и "emails".
    Объединение двух объектов "df" и "df2" по столбцу "Name" с помощью функции merge().
        df <- read.csv(...)
        userNames <-
        paste0(tolower(df$Name), sample(1:1000, nrow(df)))
        emails <- paste0(userNames, "@ujd.edu.pl")
        df2 <- data.frame(Name=df$Name, userNames, emails)
        merge(df,df2,by="Name")
    df1:
    Name	Age	City
    John	20	Paris
    Anna	25	London
    Mike	30	Berlin
    df2:
    Name	Occupation	Salary
    John	Engineer	50000
    Anna	Manager	    70000
    Kate	Designer	60000
    Чтобы объединить эти два data.frame по столбцу "Name", мы можем использовать следующий код:
    merged_df <- merge(df1, df2, by.x = "Name", by.y = "Name")
    Результат будет выглядеть так:
    merged_df:
    Name	Age	City	Occupation	Salary
    John	20	Paris	Engineer	50000
    Anna	25	London	Manager	    70000
        # Создаем таблицу df2
        df2 <- data.frame(Name = c("John", "Jane", "Jim"), Age = c(25, 30, 35))
        # Изменяем имя первого столбца на "Employee"
        names(df2)[1] <- "Employee"
        # Выводим таблицу с измененным именем столбца
        df2
    # Создаем таблицу df
    df <- data.frame(Name = c("John", "Jane", "Jim"), Salary = c(50000, 60000, 70000))
    # Создаем таблицу df2
    df2 <- data.frame(Employee = c("John", "Jane", "Jim"), Age = c(25, 30, 35))
    # Объединяем таблицы по столбцам "Name" и "Employee"
    merged_df <- merge(df, df2, by.x="Name", by.y="Employee")
    # Выводим объединенную таблицу
    merged_df
        # создание первого датафрейма
        df <- data.frame(Name = c("Alice", "Bob", "Charlie"),
                        Age = c(25, 30, 35),
                        Salary = c(50000, 60000, 70000))
        # создание второго датафрейма
        df2 <- data.frame(Employee = c("Bob", "Charlie"),
                        Email = c("bob123@example.com", "charlie456@example.com"))
        # добавление новой строки в df2
        df2 <- rbind(df2, c("Alice", "alice356", "alice356@ujd.edu.pl"))
        # объединение двух датафреймов
        merged_df <- merge(df, df2, by.x = "Name", by.y = "Employee")
    # создаем две таблицы
    df <- data.frame(Name = c("John", "Mary", "Tom"), Age = c(25, 30, 35))
    df2 <- data.frame(Employee = c("Mary", "Tom", "Bob"), Salary = c(50000, 60000, 70000))
    # выполним внутреннее соединение по столбцу "Name" и "Employee"
    inner_join(df, df2, by=c("Name"="Employee"))
    # Output:
    #   Name Age Salary
    # 1 Mary  30  50000
    # 2 Tom  35  60000
        # создаем две таблицы
        df <- data.frame(Name = c("John", "Mary", "Tom"), Age = c(25, 30, 35))
        df2 <- data.frame(Employee = c("Mary", "Tom", "Bob"), Salary = c(50000, 60000, 70000))
        # выполним правое соединение по столбцу "Name" и "Employee"
        right_join(df, df2, by=c("Name"="Employee"))
        # Output:
        #   Name Age Salary
        # 1 Mary  30  50000
        # 2












